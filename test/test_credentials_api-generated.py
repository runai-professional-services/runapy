# coding: utf-8

"""
Test file for CredentialsApi
Generated by OpenAPI Generator with custom template
"""

import pytest
import unittest.mock as mock
from datetime import datetime, timezone
import json

from runai.configuration import Configuration
from runai.api_client import ApiClient
from runai.models import *
from runai.exceptions import ApiException


class TestCredentialsApi:
    """Test cases for CredentialsApi"""

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test fixtures"""
        self.configuration = Configuration(
            client_id="test-client",
            client_secret="test-secret",
            runai_base_url="https://test.run.ai",
        )
        self.api_client = ApiClient(self.configuration)
        self.api = CredentialsApi(self.api_client)

        # Mock the request method
        self.request_patcher = mock.patch.object(self.api_client.rest_client, "request")
        self.mock_request = self.request_patcher.start()
        yield
        self.request_patcher.stop()

    def test_create_access_key(self):
        """Test case for create_access_key

        Create an access key. Use to create an S3-compatible access key credential.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        access_key_creation_request = (
            runai.AccessKeyCreationRequest()
        )  # AccessKeyCreationRequest |

        # Make request
        response = self.api.create_access_key(
            access_key_creation_request=access_key_creation_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "POST"
        assert "/api/v1/asset/credentials/access-key" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, AccessKey)

    def test_create_access_key_error(self):
        """Test error handling for create_access_key"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        access_key_creation_request = runai.AccessKeyCreationRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.create_access_key(
                access_key_creation_request=access_key_creation_request,
            )
        assert exc_info.value.status == 400

    def test_create_docker_registry(self):
        """Test case for create_docker_registry

        Create a docker registry credential. Use to create a docker registry credential containing userid, password and url.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        docker_registry_creation_request = (
            runai.DockerRegistryCreationRequest()
        )  # DockerRegistryCreationRequest |

        # Make request
        response = self.api.create_docker_registry(
            docker_registry_creation_request=docker_registry_creation_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "POST"
        assert "/api/v1/asset/credentials/docker-registry" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, DockerRegistry)

    def test_create_docker_registry_error(self):
        """Test error handling for create_docker_registry"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        docker_registry_creation_request = runai.DockerRegistryCreationRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.create_docker_registry(
                docker_registry_creation_request=docker_registry_creation_request,
            )
        assert exc_info.value.status == 400

    def test_create_generic_secret(self):
        """Test case for create_generic_secret

        Create a generic-secret. Use to create a generic-secret asset.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        generic_secret_creation_request = (
            runai.GenericSecretCreationRequest()
        )  # GenericSecretCreationRequest |

        # Make request
        response = self.api.create_generic_secret(
            generic_secret_creation_request=generic_secret_creation_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "POST"
        assert "/api/v1/asset/credentials/generic-secret" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, GenericSecret)

    def test_create_generic_secret_error(self):
        """Test error handling for create_generic_secret"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        generic_secret_creation_request = runai.GenericSecretCreationRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.create_generic_secret(
                generic_secret_creation_request=generic_secret_creation_request,
            )
        assert exc_info.value.status == 400

    def test_create_password(self):
        """Test case for create_password

        Create a userid / password credential. Use to create a userid / password credential.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        password_creation_request = (
            runai.PasswordCreationRequest()
        )  # PasswordCreationRequest |

        # Make request
        response = self.api.create_password(
            password_creation_request=password_creation_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "POST"
        assert "/api/v1/asset/credentials/password" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, Password)

    def test_create_password_error(self):
        """Test error handling for create_password"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        password_creation_request = runai.PasswordCreationRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.create_password(
                password_creation_request=password_creation_request,
            )
        assert exc_info.value.status == 400

    def test_delete_access_key(self):
        """Test case for delete_access_key

        Delete an access key. Use to delete an S3-compatible access key credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.

        # Make request
        response = self.api.delete_access_key(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "DELETE"
        assert "/api/v1/asset/credentials/access-key/{AssetId}" in kwargs["url"]

        # Verify response
        assert isinstance(response, HttpResponse)

    def test_delete_access_key_error(self):
        """Test error handling for delete_access_key"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.delete_access_key(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_delete_docker_registry(self):
        """Test case for delete_docker_registry

        Delete a docker registry credential. Use to deletes a docker registry credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.

        # Make request
        response = self.api.delete_docker_registry(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "DELETE"
        assert "/api/v1/asset/credentials/docker-registry/{AssetId}" in kwargs["url"]

        # Verify response
        assert isinstance(response, HttpResponse)

    def test_delete_docker_registry_error(self):
        """Test error handling for delete_docker_registry"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.delete_docker_registry(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_delete_generic_secret(self):
        """Test case for delete_generic_secret

        Delete a generic-secret. Use to delete a generic-secret asset, by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.

        # Make request
        self.api.delete_generic_secret(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "DELETE"
        assert "/api/v1/asset/credentials/generic-secret/{AssetId}" in kwargs["url"]

    def test_delete_generic_secret_error(self):
        """Test error handling for delete_generic_secret"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.delete_generic_secret(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_delete_password(self):
        """Test case for delete_password

        Delete a password asset. Udse to delete a password credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.

        # Make request
        response = self.api.delete_password(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "DELETE"
        assert "/api/v1/asset/credentials/password/{AssetId}" in kwargs["url"]

        # Verify response
        assert isinstance(response, HttpResponse)

    def test_delete_password_error(self):
        """Test error handling for delete_password"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.delete_password(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_get_access_key_by_id(self):
        """Test case for get_access_key_by_id

        Get an access key. Use to retrieve the details of an S3-compatible access key credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.get_access_key_by_id(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/access-key/{AssetId}" in kwargs["url"]

        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, AccessKey)

    def test_get_access_key_by_id_error(self):
        """Test error handling for get_access_key_by_id"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.get_access_key_by_id(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_get_docker_registry_by_id(self):
        """Test case for get_docker_registry_by_id

        Get a docker registry credential. Use to retrieve the details of a docker registry credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.get_docker_registry_by_id(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/docker-registry/{AssetId}" in kwargs["url"]

        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, DockerRegistry)

    def test_get_docker_registry_by_id_error(self):
        """Test error handling for get_docker_registry_by_id"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.get_docker_registry_by_id(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_get_generic_secret_by_id(self):
        """Test case for get_generic_secret_by_id

        Get a generic-secret. Returns the details of a generic-secret asset, by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.get_generic_secret_by_id(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/generic-secret/{AssetId}" in kwargs["url"]

        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, GenericSecret)

    def test_get_generic_secret_by_id_error(self):
        """Test error handling for get_generic_secret_by_id"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.get_generic_secret_by_id(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_get_password_by_id(self):
        """Test case for get_password_by_id

        Get a userid / password credential. Use to retrieve the details of a userid / password credential asset by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.get_password_by_id(
            asset_id=asset_id,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/password/{AssetId}" in kwargs["url"]

        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, Password)

    def test_get_password_by_id_error(self):
        """Test error handling for get_password_by_id"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.get_password_by_id(
                asset_id=asset_id,
            )
        assert exc_info.value.status == 400

    def test_list_access_keys(self):
        """Test case for list_access_keys

        List access keys. Use to retrieve a list of S3-compatible access key credentials.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        name = "name_example"  # str | Filter results by name.
        scope = "scope_example"  # str | Filter results by scope.
        project_id = 56  # int | Filter results by project id. if scope filter is project, only assets from the specific project will be included in the response. otherwise, the response will include both project, department, cluster and tenant assets.
        department_id = "1"  # str | Filter using the department id.
        cluster_id = "d73a738f-fab3-430a-8fa3-5241493d7128"  # str | Filter using the Universally Unique Identifier (UUID) of the cluster.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.list_access_keys()

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/access-key" in kwargs["url"]

        # Verify query parameters
        assert "name=" in kwargs["url"]
        # Verify query parameters
        assert "scope=" in kwargs["url"]
        # Verify query parameters
        assert "projectId=" in kwargs["url"]
        # Verify query parameters
        assert "departmentId=" in kwargs["url"]
        # Verify query parameters
        assert "clusterId=" in kwargs["url"]
        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, AccessKeyListResponse)

    def test_list_access_keys_error(self):
        """Test error handling for list_access_keys"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.list_access_keys()
        assert exc_info.value.status == 400

    def test_list_credentials_assets(self):
        """Test case for list_credentials_assets

        List credentials. Use to retrieve a list of all existing credentials.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        name = "name_example"  # str | Filter results by name.
        scope = "scope_example"  # str | Filter results by scope.
        project_id = 56  # int | Filter results by project id. if scope filter is project, only assets from the specific project will be included in the response. otherwise, the response will include both project, department, cluster and tenant assets.
        department_id = "1"  # str | Filter using the department id.
        cluster_id = "d73a738f-fab3-430a-8fa3-5241493d7128"  # str | Filter using the Universally Unique Identifier (UUID) of the cluster.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.list_credentials_assets()

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials" in kwargs["url"]

        # Verify query parameters
        assert "name=" in kwargs["url"]
        # Verify query parameters
        assert "scope=" in kwargs["url"]
        # Verify query parameters
        assert "projectId=" in kwargs["url"]
        # Verify query parameters
        assert "departmentId=" in kwargs["url"]
        # Verify query parameters
        assert "clusterId=" in kwargs["url"]
        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, CredentialsListResponse)

    def test_list_credentials_assets_error(self):
        """Test error handling for list_credentials_assets"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.list_credentials_assets()
        assert exc_info.value.status == 400

    def test_list_docker_registries(self):
        """Test case for list_docker_registries

        List docker registry credentials. Use to retrieve a list of docker registry credentials.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        name = "name_example"  # str | Filter results by name.
        scope = "scope_example"  # str | Filter results by scope.
        project_id = 56  # int | Filter results by project id. if scope filter is project, only assets from the specific project will be included in the response. otherwise, the response will include both project, department, cluster and tenant assets.
        department_id = "1"  # str | Filter using the department id.
        cluster_id = "d73a738f-fab3-430a-8fa3-5241493d7128"  # str | Filter using the Universally Unique Identifier (UUID) of the cluster.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.list_docker_registries()

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/docker-registry" in kwargs["url"]

        # Verify query parameters
        assert "name=" in kwargs["url"]
        # Verify query parameters
        assert "scope=" in kwargs["url"]
        # Verify query parameters
        assert "projectId=" in kwargs["url"]
        # Verify query parameters
        assert "departmentId=" in kwargs["url"]
        # Verify query parameters
        assert "clusterId=" in kwargs["url"]
        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, DockerRegistryListResponse)

    def test_list_docker_registries_error(self):
        """Test error handling for list_docker_registries"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.list_docker_registries()
        assert exc_info.value.status == 400

    def test_list_generic_secret(self):
        """Test case for list_generic_secret

        List generic-secrets. Retrieve a list of generic-secret assets.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        name = "name_example"  # str | Filter results by name.
        scope = "scope_example"  # str | Filter results by scope.
        project_id = 56  # int | Filter results by project id. if scope filter is project, only assets from the specific project will be included in the response. otherwise, the response will include both project, department, cluster and tenant assets.
        department_id = "1"  # str | Filter using the department id.
        cluster_id = "d73a738f-fab3-430a-8fa3-5241493d7128"  # str | Filter using the Universally Unique Identifier (UUID) of the cluster.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.list_generic_secret()

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/generic-secret" in kwargs["url"]

        # Verify query parameters
        assert "name=" in kwargs["url"]
        # Verify query parameters
        assert "scope=" in kwargs["url"]
        # Verify query parameters
        assert "projectId=" in kwargs["url"]
        # Verify query parameters
        assert "departmentId=" in kwargs["url"]
        # Verify query parameters
        assert "clusterId=" in kwargs["url"]
        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, GenericSecretListResponse)

    def test_list_generic_secret_error(self):
        """Test error handling for list_generic_secret"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.list_generic_secret()
        assert exc_info.value.status == 400

    def test_list_passwords(self):
        """Test case for list_passwords

        List password credentials. Use to retrieve a list of password credentials.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        name = "name_example"  # str | Filter results by name.
        scope = "scope_example"  # str | Filter results by scope.
        project_id = 56  # int | Filter results by project id. if scope filter is project, only assets from the specific project will be included in the response. otherwise, the response will include both project, department, cluster and tenant assets.
        department_id = "1"  # str | Filter using the department id.
        cluster_id = "d73a738f-fab3-430a-8fa3-5241493d7128"  # str | Filter using the Universally Unique Identifier (UUID) of the cluster.
        usage_info = True  # bool | Whether the query should include asset usage information as part of the response.
        status_info = True  # bool | Whether the query should include asset status information as part of the response.

        # Make request
        response = self.api.list_passwords()

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "GET"
        assert "/api/v1/asset/credentials/password" in kwargs["url"]

        # Verify query parameters
        assert "name=" in kwargs["url"]
        # Verify query parameters
        assert "scope=" in kwargs["url"]
        # Verify query parameters
        assert "projectId=" in kwargs["url"]
        # Verify query parameters
        assert "departmentId=" in kwargs["url"]
        # Verify query parameters
        assert "clusterId=" in kwargs["url"]
        # Verify query parameters
        assert "usageInfo=" in kwargs["url"]
        # Verify query parameters
        assert "statusInfo=" in kwargs["url"]

        # Verify response
        assert isinstance(response, PasswordListResponse)

    def test_list_passwords_error(self):
        """Test error handling for list_passwords"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.list_passwords()
        assert exc_info.value.status == 400

    def test_update_access_key(self):
        """Test case for update_access_key

        Update an access key. Use to update the details of an S3-compatible access key credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        access_key_update_request = (
            runai.AccessKeyUpdateRequest()
        )  # AccessKeyUpdateRequest |

        # Make request
        response = self.api.update_access_key(
            asset_id=asset_id,
            access_key_update_request=access_key_update_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "PUT"
        assert "/api/v1/asset/credentials/access-key/{AssetId}" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, AccessKey)

    def test_update_access_key_error(self):
        """Test error handling for update_access_key"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"
        access_key_update_request = runai.AccessKeyUpdateRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.update_access_key(
                asset_id=asset_id,
                access_key_update_request=access_key_update_request,
            )
        assert exc_info.value.status == 400

    def test_update_docker_registry(self):
        """Test case for update_docker_registry

        Update a docker registry credential. Use to updates the details of a docker registry credentials by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        docker_registry_update_request = (
            runai.DockerRegistryUpdateRequest()
        )  # DockerRegistryUpdateRequest |

        # Make request
        response = self.api.update_docker_registry(
            asset_id=asset_id,
            docker_registry_update_request=docker_registry_update_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "PUT"
        assert "/api/v1/asset/credentials/docker-registry/{AssetId}" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, DockerRegistry)

    def test_update_docker_registry_error(self):
        """Test error handling for update_docker_registry"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"
        docker_registry_update_request = runai.DockerRegistryUpdateRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.update_docker_registry(
                asset_id=asset_id,
                docker_registry_update_request=docker_registry_update_request,
            )
        assert exc_info.value.status == 400

    def test_update_generic_secret(self):
        """Test case for update_generic_secret

        Update a generic-secret. Updates the details of a generic-secret asset, by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        generic_secret_update_request = (
            runai.GenericSecretUpdateRequest()
        )  # GenericSecretUpdateRequest |

        # Make request
        response = self.api.update_generic_secret(
            asset_id=asset_id,
            generic_secret_update_request=generic_secret_update_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "PUT"
        assert "/api/v1/asset/credentials/generic-secret/{AssetId}" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, GenericSecret)

    def test_update_generic_secret_error(self):
        """Test error handling for update_generic_secret"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"
        generic_secret_update_request = runai.GenericSecretUpdateRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.update_generic_secret(
                asset_id=asset_id,
                generic_secret_update_request=generic_secret_update_request,
            )
        assert exc_info.value.status == 400

    def test_update_password(self):
        """Test case for update_password

        Update a password credential. Use to Update the details of a password credential by id.
        """
        # Mock response
        mock_response = mock.Mock()
        mock_response.status = 200
        mock_response.read.return_value = json.dumps({"data": {}})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"  # str | Unique identifier of the asset.
        password_update_request = (
            runai.PasswordUpdateRequest()
        )  # PasswordUpdateRequest |

        # Make request
        response = self.api.update_password(
            asset_id=asset_id,
            password_update_request=password_update_request,
        )

        # Verify request was made
        assert self.mock_request.called
        args, kwargs = self.mock_request.call_args

        # Verify request method and URL
        assert kwargs["method"] == "PUT"
        assert "/api/v1/asset/credentials/password/{AssetId}" in kwargs["url"]

        # Verify body
        assert kwargs["body"] is not None

        # Verify response
        assert isinstance(response, Password)

    def test_update_password_error(self):
        """Test error handling for update_password"""
        # Mock error response
        mock_response = mock.Mock()
        mock_response.status = 400
        mock_response.read.return_value = json.dumps({"message": "Error message"})
        self.mock_request.return_value = mock_response

        # Test parameters
        asset_id = "asset_id_example"
        password_update_request = runai.PasswordUpdateRequest()

        # Verify error handling
        with pytest.raises(ApiException) as exc_info:
            self.api.update_password(
                asset_id=asset_id,
                password_update_request=password_update_request,
            )
        assert exc_info.value.status == 400
